# 错题集

### 一个二叉树有100个子节点数为2的节点，100个子节点数为1的节点，那么个子节点数为0的节点（叶节点）的个数为：
- A. 101
- B. 100
- C. 200
- D. 300
- E. 99
- F. 1

答案：A. 101

解析：

度数(边数) = 所有节点数-1：这里度数=2*100+100=300，节点数：100+100+叶子节点数

所以叶子节点数=101

***

### 下面线程间的通讯机制中，关键路径上不会产生系统调用从而减少用户态到内核态的上下文切换的是____。
- A. pthread_spin_lock
- B. pthread_mutex
- C. 信号量
- D. pthread_rwlock
- E. 管道
- F. 消息队列

答案：A. pthread_spin_lock

***

### Linux 显示系统主机名的命令是？
- A. uname -r
- B. who am i
- C. uname -n
- D. whoami

答案：C. uname -n

解析：

uname -r 或 uname --release：显示操作系统的发行编号

uname -n 或 uname -nodename：显示在网络上的主机名称

who am i 等同于 who -m，只打印执行该命令的登录用户的信息

whoami 可以查询当前有效用户的名字

***

### 如何在文件中查找显示所有以“*”打头的行？

- A. find \*file
- B. wc -l *
- C. grep -n * file
- D. grep \* file

答案：D. grep \* file 

解析：

find：查找文件或目录

grep：在文件中查找字符串，语法：grep 字符串 文件名

***

### *.tar.gz 文件解压成文件，用下列哪个指令？

- A. gzip -d
- B. tar -xzf
- C. gunzip
- D. tar -xvf

答案：B. tar -xzf

解析：
1. .tar 用 tar -xvf 解压
2. .tar.gz 和 .tgz 用 tar -xzf 解压
3. .gz 用 gzip -d 或者 gunzip 解压

***

### Linux 有三个查看文件的命令，若希望在查看文件内容过程中可以用光标上下移动来查看文件内容，应使用命令：
- A. cat
- B. more
- C. less
- D. menu

答案：C. less

解析：
1. cat：一次性将文件内容全部输出
2. more：可以分页查看
3. less：使用光标向上或向下移动一行

***

### 文件exer1的访问权限为rw-r--r--，现要增加所有用户的执行权限和同组用户的写权限，下列命令正确的是：
- A. chmod a+x, g+w exer1
- B. chmod 765 exer1
- C. chmod o+x exer1
- D. chmod g+w exer1

答案：A. chmod a+x, g+w exer1

解析：

当前用户增加执行权限后为：(r + w) + x = 7

同组用户增加写权限和执行权限后为：(r) + w + x = 7

其他用户增加执行权限后为：(r) + x = 5

--> chmod 755 exer1

***

### 电子邮件地址格式为： username@hostname, 其中 hostname 为______。

- A. 用户地址名
- B. 某国家名
- C. 某公司名
- D. ISP 某台主机的域名

答案：D. ISP 某台主机的域名

解析：邮箱地址：用户名@域名

***

### 局域网的协议结构一般不包括。
- A. 网络层
- B. 物理层
- C. 数据链路层
- D. 介质访问控制层

答案：A. 网络层

解析：局域网不跨网段，不需要IP地址，只需要MAC地址就可以了

***

### 数据库文件中主数据文件扩展名和次数据库文件扩展名分别为()。
- A. .mdf .ldf
- B. .ldf .mdf
- C. .mdf .ndf
- D. .ndf .mdf

答案：C. .mdf .ndf

解析：
- .mdf primary data file
- .ndf secondary data files 
- .ldf log data file

### 有T1表数据如下：
|id1 | amount1|
| --- | ----|
|1  |    10|
|2    |  20|
|3  |    30|
|4    |  40|
|5   |   50|
|6   |   60|

有T2表数据如下：
|id2  | amount2|
| --- | ----|
|1   |  100|
|2  |   200|
|5   |  500|

执行   
```sql 
update T1 set T1.amount1=(select T2.amount2 from T2 where T1.id1=T2.id2);commit; 
```
执行之后查看 select * from t1 where id1=3;结果是哪个（   ）
- A. 0
- B. 30
- C. null
- D. 其他选项都正确


答案：C. null

解析：作为update的无关子查询，实际上是创建了两张表的笛卡尔积，所有可能的组合都会被创建出来。在笛卡尔连接中会有null的情况
|id1 | amount1|
| --- | ----|
|1  |    100|
|2    |  200|
|3  |    NULL|
|4    |  NULL|
|5   |   500|
|6   |   NULL|

其中update语句又是无条件执行的，所以3、4、6就变成了null。如果不想更新为空值，可以加exists

```sql 
UPDATE T1 
SET T1.amount1= (SELECT T2.amount2 FROM T2 WHERE T1.id1=T2.id2)
WHERE EXISTS(SELECT 1 FROM T2 WHERE T1.id1 = T1.id2);
```

***

### 设有下面两个赋值语句：
```java
a = Integer.parseInt("1024");
b = Integer.valueOf("1024").intValue();
```
下列说法正确的是（）
- A. a是整数类型变量，b是整数类对象
- B. a是整数类对象，b是整数类型变量。
- C. a和b都是整数类对象并且它们的值相等。
- D. a和b都是整数类型变量并且它们的值相等。

答案：D. a和b都是整数类型变量并且它们的值相等。

解析：
1. valueOf() 方法用于返回给定参数的原生 Number 值，是 Integer 类的一个静态方法，它是把一个 string 参数转换为 Integer 类型
2. parseInt(string)（最常用）函数可解析一个字符串，并返回一个整数（int类型）。其中参数只能是 string 类型，如果不为 string 类型，必须先转为 string 类型，同理还有：parseDouble(string), parseFloat(string)等等
3. intValue() 是 java.lang.Number 类的方法，Number 是一个抽象类。Java 中所有的数值类都继承它。也就是说，不单是 Integer 有 intValue 方法，Double, Long 等都有此方法。intValue 函数，它是将一个 Integer 类型转换成原始类型 int

***

### 关于 TCP 的滑动窗口,下面哪些描述是错误的?
- A. 发送端不需要传输完整的窗口大小的报文 
- B. TCP 滑动窗口允许在收到确认之前发送多个数据包
- C. 重传计时器超时后,发送端还没有收到确认,会重传未被确认的数据
- D. 发送端宣告初始窗口大小

答案：D. 发送端宣告初始窗口大小

解析：
接收端告诉发送端自己的接收窗口大小。

MSS(Max Segement Size)是 TCP 数据包每次能够传输的最大数据分段，其中并不包括 TCP 首部，而且 MSS 只出现在 syn 报文段中。

一般来说，MSS 的值在不分段的情况会越大越好，比如一个外出接口的 MSS 值时 MTU 减去 IP 和 TCP 首部长度。

窗口大小是一个动态的值，因为 TCP 用的是滑动窗口协议,传输数据的速率都是根据窗口大小来调整的。

可以把窗口理解为一个缓存，而窗口大小跟 MSS 是没有任何关系的。

窗口是为了控制传输过程中的速度；而 MSS 只是控制 TCP 报文段大小。

窗口大小可以认为是一个通信管道的大小，跟具体每个报文段大小没有直接关系。

***

### 在公司局域网上 ping www.iwhalecloud.com 没有涉及到的网络协议是：（ ）
- A. TCP
- B. DNS
- C. ICMP
- D. ARP

答案：A. TCP

解析：
ping 命令使用的是 ICMP(Internet Control Message Protocal) 协议，ICMP 直接作为数据部分塞入 IP 报文，而不用通过 TCP 或 UDP

整个过程先使用 DNS 来得到该域名的 IP 地址；

再通过 ARP 由 IP 地址得到物理地址

***

### 以下关于Cookie的描述不对的是（）
- A. 根域名可以访问子域的Cookie
- B. 浏览器禁用Cookie时可以用URL重写与服务端保持状态
- C. Cookie有大小限制
- D. Cookie中保存的是字符串

答案：A. 根域名可以访问子域的Cookie

解析：
A. 子域名 cookie 可以访问根域名，反之不行

B. 为保持 HTTP 状态，不使用 cookie，可以对 URL 进行重写：例如 SessionID 写入 URL 参数

***

### 对于索引以下正确的描述是（）
- A. 字段被查询使用时，如果此字段上存在索引，则索引就会被使用
- B. 索引与DML速度无关
- C. 索引创建后会自动被Oracle使用
- D. 索引扫描未必优于全表扫描

答案：D. 索引扫描未必优于全表扫描

解析：
A.D 索引中有优化器，当数据量少的时候，选择不用索引
C Oracle 是择优选用索引

***

### 关于抽象类叙述正确的是？ ()
- A. 抽象类不能实现接口
- B. 抽象类必须有“abstract class”修饰
- C. 抽象类必须包含抽象方法
- D. 抽象类也有类的特性，可以被实例化

答案：B. 抽象类必须有“abstract class”修饰

解析：

A. 抽象类是可以实现接口的，而且抽象类也可以继承自抽象类

C. 抽象类指有 abstract 修饰的 class，其可以包含抽象方法，也可以不包含

D. 抽象类和接口都是不能被实例化的，只有具体的类才可以被实例化

***

### 下面关于Linux文件系统的inode描述错误的是：
- A. inode和文件是一一对应的
- B. inode描述了文件大小和指向数据块的指针
- C. 通过inode可获得文件占用的块数
- D. 通过inode可实现文件的逻辑结构和物理结构的转换

答案：A. inode和文件是一一对应的

解析：硬链接 1 个 inode 号码可能对应多个文件

***

### 在SQL中，下列哪个命令用于从数据库中删除索引？
- A. DELETE
- B. DROP
- C. REMOVE
- D. ROLL BACK

答案：A. DELETE

***

### 现需要将一个网络划分为5个子网，每个子网至少有16个主机。则应该使用下列哪一个子网掩码？
- A. 255.255.255.192
- B. 255.255.255.224
- C. 255.255.255.240
- D. 255.255.255.248

答案：B. 255.255.255.224

解析：
- 主机数量 = 2^n - 2，n 是主机号位数
- 子网数 = 2^n，n 是子网号位数
- 主机数 = 256 - 子网掩码 - 2

需要划分出 5 个子网，每个子网 16 个主机

子网的网络位位数应该为 3（2^3=8>5），16 个主机加上网络地址、广播地址以及网关地址，需要 19，也就是说子网主机位需要 5 个 

因此 32 位子网掩码最后 8 位应该是：1110 0000，换成十进制是 224

***

### 下列哪一项关于用户级和内核级线程的说法是不正确的？
- A. 用户级线程不需要任何硬件支持
- B. 阻塞一个内核级线程就会阻塞所有相关的线程
- C. 用户级线程的上下文切换时间比内核级线程要少
- D. 可以在多处理器系统中的不同处理器上调度相关的内核级线程

答案：B. 阻塞一个内核级线程就会阻塞所有相关的线程

解析：B. 内核线程的映射可能有一对一、一对多和多对多，B 描述的是用户级线程的特征

***

### 有关多线程，多进程的描述错误的是？（）
- A. 子进程获得父进程的数据空间，堆和栈的复制品
- B. 线程可以与同进程的其他线程共享数据，但是它拥有自己的栈空间且拥有独立的执行序列
- C. 线程执行开销小，但是不利于资源管理和保护
- D. 进程是CPU调度和分派的基本单位

答案：D. 进程是CPU调度和分派的基本单位

解析：进程是操作系统分配资源的基本单位，线程是cpu调度和分派的基本单位

***

### 多个进程怎样共享一个监听端口？（）
- A. 每个进程都使用SO_REUSEADDR选项，然后绑定同一个端口
- B. 每个进程分别绑定一次即可
- C. 使用fork共享
- D. 只有最后一个绑定端口的进程才能收到数据

答案：C. 使用fork共享

解析：fock函数会复制父进程中的所有数据，当然也包括监听套接字

A. SO_REUSEADDR是setsockopt的参数，使端口被释放后立即可以再使用

***

### 以下关于数字签名说法正确的是?
- A. 数字签名是在所传输的数据后附加上一段和传输毫无关系的数字信息
- B. 数字签名能够解决篡改，伪造等安全性问题
- C. 数字签名一般采用对称加密机制
- D. 数字签名能够解决数据的加密传输，即安全传输问题

答案：B. 数字签名能够解决篡改，伪造等安全性问题

解析：数字签名技术是将摘要用发送者的私钥加密，与原文一起传送给接收者。接收者只有用发送者的公钥才能解密被加密的摘要，然后用Hash函数对收到的原文产生一个摘要，与解密的摘要对比，如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则，就是被修改过，不是原信息。同时，也证明发送者发送了信息，防止了发送者的抵赖。

实现数字签名的主要技术是非对称密钥加密技术。C错

数字签名并不能保证信息在传输过程中不被截获。D错

***

### 在Linux中查看ARP缓存记录的命令是?
- A. “arp –a”
- B. “arp –d”
- C. “arp -L”
- D. “arp –D”

答案：A. “arp –a”

解析：
- A “arp –a”:all 显示arp缓冲区的所有条目
- B “arp –d”:delete 从arp缓冲区中删除指定主机的arp条目
- C 没有这个参数
- D “arp –D”:Device 使用指定接口的硬件地址

***

### 虚拟内存容量受()的限制?
- A. 磁盘空间大小
- B. 物理内存大小
- C. 数据存放的实际地址
- D. 计算机地址位数

答案：AD

解析：

虚存的大小要同时满足2个条件：
1. 虚存的大小  ≤ 内存容量和外存容量之和。
2. 虚存的大小  ≤ 计算机的地址位数能容纳的最大容量。

***

### 下面关于 RSA 算法的描述,不正确的是?
- A. RSA 的运行速度相比 AES 算法要慢很多
- B. RSA 的安全性依赖于大数分解
- C. TLS/SSL 协议中 RSA 的公钥长度一般为 256 位或 512 位
- D. RSA 是非对称加密算法

答案：C. TLS/SSL 协议中 RSA 的公钥长度一般为 256 位或 512 位

解析：RSA一般为1024或2048位

***

### 下列关于网络编程的描述中,错误的是?
- A. 一个 Socket 可以绑定多个网卡
- B. 客户端和服务器端都可以主动关闭 Socket
- C. Socket 支持阻塞模式和非阻塞模式
- D. TCP 和 UDP 协议不能绑定同一端口

答案：C. TLS/SSL 协议中 RSA 的公钥长度一般为 256 位或 512 位

解析：TCP、UDP可以绑定同一端口来进行通信

当TCP和UDP提供相同的服务时，会选用相同的端口号

一般情况下：

在网络层IP数据包向上传递的时候会查看数据包中的协议类型

如果协议类型是TCP，则交给TCP

如果协议类型是UDP，则交给UDP

到了传输层，再根据端口号将数据传送到应用层相应的应用程序，TCP、UDP端口是独立的

### 设有2条路由21.1.193.0/24和21.1.194.0/24，如果进行路由汇聚，汇聚这两条路由的地址是 ()
- A. 21.1.200.0/22 
- B. 21.1.192.0/23
- C. 21.1.192.0/21
- D. 21.2.224.0/20

答案：C. 21.1.192.0/21

解析：路由汇聚算法。193 = 1100 0001；194 = 1100 0010，前 6 位相同，因此掩码长度为 8+8+6 = 22。

1100 0000 = 192，最终答案为 21.1.192.0/22，需要找一个包含正确答案的正确选项

路由汇聚就是找到两路由不同地方，换算成二进制后找到能匹配的最大长度，则能匹配的最大长度再换算成的十进制便是汇聚后的结果

新掩码的最大长度= 原掩码长度-不匹配的长度

### 上网时候发现网页不能访问，QQ使用正常，出现此问题可能的原因是：
- A. 网线问题 
- B. DNS问题
- C. IP地址冲突
- D. 网关错误

答案：B. DNS问题

解析：DNS是将域名解析成IP地址的服务。DNS发生问题时无法通过域名访问网页；但是直接通过IP地址连接的应用程序仍可以使用。

### 下列地址中的哪一个地址和86.32/12无法匹配？（ ）
- A. 86.33.224.123
- B. 86.79.65.216
- C. 86.58.119.74
- D. 86.68.206.154

答案：B C D

解析：子网掩码为 12 位，前 8 位 4 个选项都匹配，主要看 9-12 位。

32 的二进制前四位 - 0010
- A. 33 - 0010 
- B. 79 - 0100
- C. 58 - 0011
- D. 68 - 0100

### UDP报头中没有下面那些信息?()
- A. 目的地址
- B. 窗口大小
- C. 序列号
- D. 检验和

答案：A B C 

解析：UDP报头只有四个域：源端口号，目的端口号，数据报长度，检验和。

### 对于JVM内存配置参数：-Xmx10240m -Xms10240m -Xmn5120m -XXSurvivorRatio=3, 其最小内存值和Survivor区总大小分别是（）
- A. 5120m，1024m
- B. 5120m，2048m
- C. 10240m，1024m
- D. 10240m，2048m

答案：D. 10240m，2048m

解析：
- Xmx: 最大堆大小
- Xms: 初始堆大小
- Xmn：新生代大小
- XXSurvivorRatio: 年轻代中 Eden 区与 Survivor 区的大小比值

新生代分为：Eden，2 块 Survivor，Eden : Survivor = 3 -> 3x + x + x = 5120 -> x = 1024

Xms初始堆大小即最小内存值为10240m

### 不能用来修饰interface的有（ ）（仅限外部接口）
- A. private
- B. public
- C. protected
- D. static

答案：A C D

解析：接口是一种特殊的抽象类，接口中的方法全部是抽象方法（但其前的abstract可以省略），所以抽象类中的抽象方法不能用的访问修饰符这里也不能用。

而且protected访问修饰符也不能使用，因为接口可以让所有的类去实现（非继承），不只是其子类，但是要用public去修饰。

### 对象间存在一对多关系，当一个对象被修改时，则会自动通知它的依赖对象，采用以下哪种设计模式最好？
- A. 建造者模式
- B. 观察者模式
- C. 策略模式
- D. 代理模式

答案：B. 观察者模式

解析：
- 观察者模式：对象间存在一对多关系，如果一个对象被修改时，会自动通知它的依赖对象。
- 建造者模式：使用对各简单的对象一步一步构建出一个复杂对象
- 代理模式：指一个类别可以作为其他东西的接口
- 策略模式：将每一个算法封装起来，使得每个算法可以相互替代，使得算法本身和使用算法的客户端分割开来相互独立

### 如果强调一系列相关产品的接口，以便联合使用它们的时候，应该选择何种设计模式：
- A. 模板方法模式
- B. 备忘录模式
- C. 抽象工厂模式
- D. 组合模式

答案：C. 抽象工厂模式

解析：
- 模版模式：定义一个算法结构，而将一些步骤延迟到子类去实现
- 备忘录模式：在不破坏封装的前提下，保持对象的内部状态
- 抽象工厂模式：创建相关或依赖对象的家族，而无需指明具体类
- 组合模式：将对象组合成树形结构以表示部分和整体的层次结构

### 以下关于外观模式的叙述中正确是（ ）
- A. 外观模式符合单一职责原则
- B. 在外观模式中，一个子系统的外部与内部通信通过统一的外观对象进行
- C. 在外观模式中，客户类只需要直接与外观对象进行交互
- D. 外观模式是迪米特法则的一种具体实现

答案：B C D

解析：外观模式：把子系统的功能封装到一个类里，对外只提供这一个类，适合于老系统对外提供接口

- A. 外观模式是本系统向外部封装提供一个统一的接口，以用来隐藏本系统的复杂性。 而单一职责原则告诉我们，一个对象或一个系统，应该只关注本身的实现，而不要操心别人怎么使用自己

### 在同一包下，以下说法正确的是
- A. super.方法() 可以调用父类的所有非私有方法
- B. super() 可以调用父类的所有非私有函数
- C. super.属性可以调用父类的所有非私有属性
- D. this和super关键字可以出现在同一个构造函数中

答案：A B C D


### 下列对于重载描述错误的是
- A. 方法重载只能发生在一个类的内部
- B. 构造方法能重载，但静态方法不能重载
- C. 重载要求方法名相同，参数列表不相同
- D. 方法的返回值类型不是区分方法重载的条件

答案：B

解析：静态方法可以重载


### 下列对接口描述错误的有
- A. 接口没有提供构造方法
- B. 接口中的方法默认使用 public、abstract 修饰
- C. 接口中的属性默认使用 public、static、final 修饰
- D. 接口不允许多继承

答案：D

解析：
- interface 可以多继承 interface；
- class 只能单继承 class，但可以多实现 interface；
 abstract 具有类的特性，可以多 implement interface，但只能单 extends class 或者 abstract class
 
 
### 以下关于异常的描述错误的是
- A. RuntimeException：可以不使用 try...catch 进行处理，但是如果有异常产生，则异常将由 JVM 进行处理
- B. finally 语句块是不管有没有出现异常都要执行的内容
- C. throw 关键字可以在方法上声明该方法要抛出的异常
- D. try 是用于检测被包住语句块是否出现异常，如果有异常，则抛出异常，并执行 catch 语句

答案：C. throw 关键字可以在方法上声明该方法要抛出的异常

解析：关键字是 throws，throw 是动作

### 找出以下关于 float 的不正确的声明
- A. float foo = -1;
- B. float foo = 1.0;
- C. float foo = 2.02f;
- D. float foo = 0x0123;

答案：B. float foo = 1.0;

解析：
- float a = 1; 这里 a 是整形，当赋值给一个 float 时，存在一个隐式转换，不损失精度
- float a = 1f; 1f 就是 float 类型
- float a = 1.0; 肯定出错，因为 1.0 默认是 double 类型的，double 范围比 float 大，会损失精度

### 以下哪个是 Java 线程 Thread 启动的方法
- A. run()
- B. execute()
- C. start()
- D. go()

答案：C. start()

解析：
- run() 不开启线程，仅仅是 Thread 方法中的一个普通方法调用，在主线程里执行
- start() 开启线程，并让 JVM 调用 run() 在开启的线程中执行

### 下面说法正确的是
- A. LinkedList 是使用了链表结构，特点是查找效率高
- B. 在高并发，多线程的情况下要使用高效率 HashMap
- C. ArrayList 是一个动态数组能自动扩展，所以设置初始长度没必要
- D. Set 集合内元素不能重复，使用 equals() 来判断元素是否相等

答案：C. ArrayList 是一个动态数组能自动扩展，所以设置初始长度没必要

解析：
- run() 不开启线程，仅仅是 Thread 方法中的一个普通方法调用，在主线程里执行
- start() 开启线程，并让 JVM 调用 run() 在开启的线程中执行


### 关于Java虚拟机垃圾回收以下说法正确的有哪些？
- A. Java虚拟机中的自动垃圾回收机制能阻止程序运行时内存溢出
- B. 垃圾回收是一个独立的平台
- C. 当一个对象的所有引用都被置为空时，该对象就可以变为能被垃圾回收的
- D. System.gc()可以建议垃圾回收执行，但不能强迫其执行；

答案：C D

解析：
- A：GC 直接减缓内存溢出的出现，但并不会阻止内存溢出
- B：垃圾回收只是一个 daemon 线程


### 关于抽象类说法以下哪些是正确的？
- A. 抽象类中可以不存在任何抽象方法
- B. 抽象类可以为final的
- C. 抽象类可以被抽象类所继承
- D. 如果一个非抽象类从抽象类中派生，不一定要通过覆盖来实现继承的抽象成员

答案：A C

解析：
- B D：抽象类必须要被覆盖，所以不能和 final 一起用

### 当路由收到目标为202.38.17.98的IP包时，将选取哪个路由项转发？
- A. 202.38.17.0/25
- B. 202.38.17.32/27
- C. 202.38.17.64/26
- D. 202.38.17.96/27

答案：D. 202.38.17.96/27

解析：ACD都是对的，但是，在路由中如果这三个都存在的话，那么就需要使用“最长匹配原则”，选择子网掩码最长的进行转发。

### 关于TCP/IP协议中的TCP和UDP以下哪些表述是正确的？
- A. TCP和UDP包头结构中都不包含目的地址的IP
- B. 视频、聊天等数据的传输都可以基于UDP协议
- C. 数据通过UDP协议传输存在丢包的可能，因此其传输可靠性不如TCP协议
- D. UDP和TCP包都是固定长度的

答案：A B C

解析：A: 目标IP地址包含在IP头部中

### 以下说法正确的有()
- A. 多个进程操作同一个文件时，应该要考虑到文件的一致性问题
- B. 可通过文件在不同进程间进行数据传递和共享
- C. 可以通过全局变量在不同进程间传递数据
- D. 一个进程可以访问到所有物理内存空间

答案：A B

解析：
- C: 全局变量在每个进程中是独立的，只有在同一个进程内的线程之间可以共享
- D: 进程之间地址空间相互独立 

### IP数据报分片的重组通常发生在()
- A. 源主机和数据报经过的路由器上
- B. 源主机上
- C. 数据报经过的路由器上
- D. 目的主机上

答案：D. 目的主机上

解析：当一个 IP 数据报封装成链路层的帧时，此数据报的总长度（即报头区加上数据部分）一定不能超过下层的数据链路层的 MTU 值，否则无法传输。

因此，我们需要对 IP 包进行分片，其中 IP 数据报的首部中，和 IP 数据包分片有关的字段为——总长度、标识、标志以及位偏移。

**分片由网络层的路由器完成**

目的主机收到所有分片后，对分片进行重新组装还原的过程叫做 IP 数据报重组。

IP 协议规定，**只有最终的目的主机才可以对分片进行重组**。

目的主机接收到所有的数据报的分包之后，根据数据包首部中保存的信息，还原最初的数据包。这就是数据包的重组过程。

### 下面算法中可以判断出一个有向图是否有环的是：（）
- A. 求最短路径
- B. 深度优先遍历
- C. 广度优先遍历
- D. 拓扑排序

答案：B D

解析：
- C: 广度优先搜索过程中如果访问到一个已经访问过的节点，可能是多个节点指向这个节点，不一定是存在 cycle。


### 以太网媒体访问控制技术CSMA/CD的机制是（   ）。
- A. 争用带宽
- B. 预约带宽
- C. 循环使用带宽
- D. 按优先级分配带宽

答案：A. 争用带宽

解析：

考点：计算机网络 —— 链路层 —— 信道复用

CSMA/CD 即 **载波监听多点接入/碰撞检测**，是广播型信道中采用的一种随机访问技术的竞争型访问方法。
- 多点接入：说明这是总线型网络，许多主机以多点的方式连接到总线上。
- 载波监听：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。
- 碰撞检测：在发送中，如果监听到信道已有其他主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。
 - 记端到端的传播时延为 π，最先发送的站点最多经过 2π 就可以知道是否发生了碰撞，所以称 2π 为争用期。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。

实际上 CSMA/CD 的工作流程与人际间通话非常相似：有别人说话，我就不说；我说话时，别人就不说，所以是争用。

### 下列关于修饰符混用的说法，错误的是( )
- A. abstract不能与final并列修饰同一个类
- B. abstract类中不应该有private的成员
- C. abstract方法必须在abstract类或接口中
- D. static方法中能直接调用类里的非static的属性

答案：D. static方法中能直接调用类里的非static的属性

解析：
- A：一个类要么能继承要么不能继承
- B：抽象类无法实例化对象，所以使用 private 成员没有意义
- C：抽象方法，不是在抽象类里就是在接口里，没有第三方选择！
- D：在JVM中static方法在静态区，静态区无法调用非静态区属性。

### 下面关于线程的叙述中，正确的是（）。
- A. 不论是系统支持线程还是用户级线程，其切换都需要内核的支持
- B. 线程是资源的分配单位，进程是调度和分配的单位
- C. 不管系统中是否有线程，进程都是拥有资源的独立单位
- D. 在引入线程的系统中，进程仍是资源分配和调度分派的基本单位

答案：C. 不管系统中是否有线程，进程都是拥有资源的独立单位

解析：
- A：用户级线程是指有关线程的所有管理工作都由用户态运行的线程库(如POSIX的pthread库)完成，系统内核并不知道线程的存在。应用程序可以根据需要，在同一个进程中创建线程，自己设计调度单位，调度指定线程运行。由于内核是单线程，仍以进程为单位进行调度。核心级线程(系统支持线程)是指有关线程的所有管理工作都是由系统内核完成的。
- B：对于普通的操作系统，未引入线程的话，进程是系统进行资源分配和调度的独立单位。
- D：在多处理机操作系统中，引入线程后，进程是资源的分配单位或者叫做资源的容器，线程是处理机的调度单位。

### 在 Java 中，要使某个类能被同一个包中的其他类访问，但不能被这个包以外的类访问，可以（）。
- A. 让该类不使用任何关键字
- B. 使用 private 关键字
- C. 使用 protected 关键字
- D. 使用 public 关键字

答案：A. 让该类不使用任何关键字

解析：

修饰符| 类内部| 本包| 子类 | 外部包
|-----|-----|-----|------|------|
public|  √  |  √  |  √   |  √
protected| √|  √  |  √   |  × 
default| √  |  √  |  ×   |  ×
private| √ |   ×  |  ×   |  ×


### 选项中哪一行代码可以替换题目中的 // add code here（）。
```java
public abstract class MyClass {
 public int constint = 5;
 // add code here
 public void method() {
 }
}
```
- A. public abstract void method(int a)
- B. constint = constint + 5;
- C. public int method();
- D. public abstract void anotherMethod(){};

答案：A. public abstract void method(int a)

解析：
- A：该方法是抽象方法，所以没有方法体，和题目总的 method() 方法构成了方法重载（方法名一致，参数不一致）
- B：抽象类体中只能定义变量和方法，不能有其他语句，加{}组成代码块后正确
- C：选项中的方法和类中的方法重复，会发生编译异常
- D：抽象方法不能有方法体，应该去掉{}

### 下列关于软链接描述正确的是（）。
- A. 与普通文件没什么不同，inode 都指向同一个文件在硬盘中的区块
- B. 不能对目录创建软链接
- C. 保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问时替换自身路径
- D. 不可以对不存在的文件创建软链接

答案：C. 保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问时替换自身路径

解析：
- A：后半句说的是硬链接。硬链接是共同拥有同一个 inode，不过是每个链接名不同，暂时理解成不同的文件名却指向同一个文件。一个文件每加一个硬链接 linkcount + 1
- B：可以对目录创建软链接
- C：软链接创建一般用绝对路径，否则可能会报错。软链接一个文件或目录的软链接和普通文件一样，有自己的数据块和 inode；而硬链接是同用文件的 inode 和数据块
- D：可以对不存在的文件创建软链接

### 将两个各有N个元素的有序表归并成一个有序表,其最少的比较次数是()，最多的比较次数是（）。

答案：N  2N-1

解析：
假设A中元素都比B中要小，则先比较N次将A中元素取完，然后再依次取B中元素。

### 简单网络管理协议 SNMP 处于网络体系结构的哪一层（）。
- A. 互联层
- B. 传输层
- C. 应用层
- D. 逻辑链路控制层

答案：C. 应用层

解析：简单网络管理协议是目前 Internet 上广泛使用的一种网络管理协议。SNMP 在网络体系结构中属于应用层结构。它建立在 TCP/IP 协议簇中的 UDP 协议之上，提供无连接服务。尽管这是一种不可靠的服务，但保证了信息快速传递。SNMP 结构简单，符合关于“网络管理增加的资源必须对原系统的影响尽量小”的原则。SNMP 模型由 3 部分组成：管理进程（Manager）、管理代理（Agent）、管理信息库（MIB）

### 用二分（对半）查找表的元素的速度比用顺序法（）。
- A. 必然快
- B. 必然慢
- C. 相等
- D. 不能确定

答案：D. 不能确定

解析：当查找表中元素个数为 1 个或 2 个时，二分法和顺序法速度相等；当元素个数大于 2 个时，如果是有序表，那么二分法更快。

### 关于HTTP协议，下面哪个说法是正确的？
- A. HTTP协议是有状态协议。
- B. 以下是一个Http链接的response 的响应头： GET /xxx/xxx/js/lib/test.js HTTP/1.1 Host: 127.0.0.1 Connection: keep-alive Pragma: no-cache Cache-Control: no-cache Accept: */*
- C. RESTful 接口中，利用HTTP协议的method字段来描述要对资源操作的方式，比如GET表示获取资源，POST表示新增一个资源，PUT表示更新资源,DELETE 表示删除资源等等。
- D. 一个HTTP请求返回的HTTP状态码中，304表示临时重定向。

答案：C

解析：
- A：HTTP 无状态
- B：后面是 request 头
- D：状态码304表示：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。307表示临时重定向！！！

### 关下面关于DNS说法错误的是（）？
- A. DNS的作用是域名和IP地址的相互映射。
- B. DNS协议运行在UDP协议之上
- C. DNS协议端口号为53
- D. DNS的默认缓存时间为1小时

答案：D

解析：
- D：浏览器：chrome对每个域名会默认缓存60s，IE将DNS缓存30min，Firefox对DNS缓存功能，但是默认缓存时间只有1分钟，safari约为10s。

windows DNS缓存的默认值是MaxCacheTTL，它的默认值是86400s，也就是一天。

浏览器DNS缓存的时间跟ttl值无关，每种浏览器都使用一个固定值。


### 下列关于修饰符混用的说法，错误的是（）
- A. abstract 方法必须在 abstract 类或接口中
- B. static 方法中能直接处理非 static 的属性
- C. abstract 不能与 final 并列修饰同一个类
- D. abstract 类中不建议有 private 的成员

答案：B. static 方法中能直接处理非 static 的属性

解析：
- A：抽象类中可以没有抽象方法，但是抽象方法必须在抽象类或接口中
- B：被static修饰的都是跟随类的加载而加载，优先于对象存在，所以静态不能调用非静态，非静态可以调用静态
- C：abstract 修饰的类，不可实例化，所以需要子类去继承，然后重写其中的抽象方法；但是final修饰类是不可继承的，两者属性相冲

### 下列关于线程优先级的说法中，正确的是( )。
- A. 线程的优先级是不能改变的
- B. 线程的优先级是在创建线程时设置的
- C. 在创建线程后的任何时候都可以设置
- D. B和C

答案：C. 在创建线程后的任何时候都可以设置

解析：线程的优先级在创建线程时可以设置，也可以通过getPriority()方法来获得线程的优先级，通过setPriority()方法来设定线程的优先级

### 什么是 LinkedHashSet？
- A. 是一个 HashSet，保留了对象插入的顺序
- B. 是一个 HashSet，拥有一个链表的性能
- C. 是一个 HashSet，能很容易地转换为一个链表
- D. HashSet 对象的超类

答案：A. 是一个 HashSet，保留了对象插入的顺序

解析：LinkedHashSet继承自HashSet，唯一的区别是LinkedHashSet内部使用的是LinkHashMap。这样做的意义或者好处就是LinkedHashSet中的元素顺序是可以保证的，也就是说遍历序和插入序是一致的。

### 在使用super 和this关键字时，以下描述正确的是（）
- A. 在子类构造方法中使用super()显式调用父类的构造方法，super()必须写在子类构造方法的第一行，否则编译不通过
- B. super()和this()不一定要放在构造方法内第一行
- C. this()和super()可以在static环境中使用，包括static方法和static语句块
- D. this()和super()可以同时出现在同一个构造函数中

答案：A. 在子类构造方法中使用super()显式调用父类的构造方法，super()必须写在子类构造方法的第一行，否则编译不通过

解析：
- A：每个子类构造方法的第一条语句，其实都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错
- B：super()和this()均需要放在构造方法内第一行
- C：this()和super()都指的是对象，所以，均不可以在static环境中使用，包括：static变量、static方法、static语句块
- D：this()和super()不可以同时出现在同一个构造函数中，因为this()必然会调用其它的构造函数，其它的构造函数必然也会有super()语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过，所以尽管可以用this调用一个构造器但却不能调用2个。


### 下列哪些语句关于内存回收的说明是正确的? (  )
- A. 程序员必须创建一个线程来释放内存
- B. 内存回收程序负责释放无用内存
- C. 内存回收程序允许程序员直接释放内存
- D. 内存回收程序可以在指定的时间内释放内存对象

答案：B. 内存回收程序负责释放无用内存

解析：
- A：JVM一旦启动，就会创建一个守护线程来检测是否需要有对象内存被释放
- C：无法直接释放
- D：不可以指定时间，System.gc()，只是提醒JVM可以进行一次 full GC，但是什么时候真正执行是不知道的

![GC](/images/GC.png)

### ArrayList list = new ArrayList(20); 中的list被扩容几次? 
- A. 0
- B. 1
- C. 2
- D. 3

答案：A. 0

解析：

ArrayList 的构造函数总共有3个：
1. ArrayList() 构造一个初始容量为 10 的空列表。
2. ArrayList(Collection<? extends E> c) 构造一个包含指定collection的元素的列表，这些元素是按照该collection的迭代器返回它们的顺序排列的
3. ArrayList(int initialCapacity) 构造一个具有指定初始容量的空列表

调用的是第三个构造函数，直接初始化为大小20的list，所以没有扩容。

### 下列关于内部类的说法不正确的是? (  )
- A. 内部类的类名只能在定义它的类或程序段中或在表达式内部匿名使用
- B. 内部类可以使用它所在类的静态成员变量和实例成员变量
- C. 内部类不可以用abstract修饰符定义为抽象类
- D. 内部类可作为其他类的成员，而且可访问它所在类的成员

答案：C. 内部类不可以用abstract修饰符定义为抽象类

解析：
- A：内部类可以看做是一个人的心脏
- C：内部类不仅可以用abstract修饰定义为抽象类，还可以用private或protected定义


### 下列选项中，不属于模块间耦合的是（）。
- A. 数据耦合
- B. 同构耦合
- C. 异构耦合
- D. 公用耦合

答案：C. 异构耦合

解析：模块之间的耦合程度反映了模块的独立性，也反映了系统分解后的复杂程度

按照耦合程度从弱到强，可以将其分成5级，分别是：数据耦合、同构耦合、控制耦合、公用耦合和内容耦合。

### 在Java MVC涉及模式中，（）接收用户请求数据。
- A. HTML
- B. JSP
- C. Servlet
- D. JavaBean

答案：C. Servlet

解析：
- B：JSP属于视图层，用于收集用户输入与向用户显示数据
- C：Servlet属于控制器，处理数据
- D：JavaBean属于模型，进行封装和简单处理

### 主机甲向主机乙连续发送了两个TCP报文段，其序号分别为70和100。下列错误的是
- A. 第一个报文段携带了30个字节的数据
- B. 主机乙收到第一个报文段后发回的确认中的确认号是100
- C. 如果主机乙收到第二个报文段后发回的确认中的确认号是180，那么甲发送的第二个报文段中的数据有80字节
- D. 如果甲发送的第一个报文段丢失了，但第二个报文段到达了乙，乙在第二个报文段到达后向甲发送确认，这个确认号为100

答案：D. 如果甲发送的第一个报文段丢失了，但第二个报文段到达了乙，乙在第二个报文段到达后向甲发送确认，这个确认号为100

解析：

第一步，甲向乙发送数据包 ，序列号为70

第二步，乙向甲发送确认包，确认号假设为x（x为甲 发送的上一个数据包中的序列号+所该数据包中所带数据的大小=70+该数据包大小 ）

第三步，甲向乙发送数据包，序列号为上一次的确认号x

根据题意

所以x=100，数据包大小为30

所以AB正确，C同理分析也正确

D，如果第一个丢了，但是第二个到了乙，根据TCP/IP快速恢复和重传机制，乙发送的确认号仍然是第一个包的序列号70。

### 堆是一种数据结构，( )是堆
- A. （10,50,80,30,60,20,15,18）
- B. （10,18,15,20,50,80,30,60）
- C. （10,15,18,50,80,30,60,20）
- D. （10,30,60,20,15,18,50,80）

答案：B. （10,18,15,20,50,80,30,60）

解析：
方法一：用数组表示堆结构时，i为父结点，其子结点分别为2*i和2*i+1.堆的数据结构特点：子结点的键值或索引总是小于（或者大于）它的父节点。（由此产生了堆排序）

方法二：把这个序列看成数组型的二叉树，如果根结点是i，左子树是2*i，右子树是2*i+1。堆分为最大堆与最小堆。

1. 最大堆中所有父节点都比左子树、右子树大，比如已知序列，画成堆就是： 
![maxHeap](/images/maxHeap.png)

2. 最小堆中所有父节点都比左子树、右子树小，比如{32,50,60,70,100,65},画成堆： 
![maxHeap](/images/minHeap.png)




