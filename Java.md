# Java类错题

## Java垃圾回收算法CMS执行的顺序是（）
- A. 初始标记->并发标记->并发预清理->重新标记->并发清理->并发重置 
- B. 初始标记->并发标记->重新标记->并发预清理->并发清理->并发重置
- C. 初始标记->并发预清理->并发标记->重新标记->并发清理->并发重置
- D. 初始标记->并发标记->重新标记->并发预清理->并发重置->并发清理

答案：A. 初始标记->并发标记->并发预清理->重新标记->并发清理->并发重置 

## 下面有关java类加载器，说法正确的是？
- A. 引导类加载器（bootstrap class loader）：它用来加载Java的核心库，是用原生代码来实现的
- B. 扩展类加载器（extensions class loader）：它用来加载Java的扩展库
- C. 系统类加载器（system class loader）：它根据Java应用的类路径（CLASSPATH）来加载Java类
- D. Tomcat为每个APP创建一个Loader，里面保存着此WebApp的ClassLoader。需要加载WebApp下的类时，就取出ClassLoader来使用

答案：ABCD

## 下面哪些说法是正确的？（ ）
- A. java语言是真正的面向对象的语言，任何代码都是类的一部分。
- B. 运行java程序必须需要java运行环境的支持，例如需要java虚拟机JVM。
- C. 使用Visual J++在windows下开发的所有java程序可以不加修改的在Unix下运行，这是java程序“一次编写，到处运行”的特点决定的。
- D. java语言的类加载器可以实现从互联网上加载java程序。

答案：BCD

## 下面哪个方法是 public void  example(){...} 的重载方法？ ( )
- A. public void Example( int m){...}
- B. public int example(){...}
- C. public void example2(){...}
- D. public int example ( int m, float f){...}

答案：D

解析：方法重载要求函数名完全相同，参数列表不同（数量，类型或位置均可）；返回值类型、方法修饰符不影响。

## 下列哪一种叙述是正确的（）
- A. abstract修饰符可修饰字段、方法和类
- B. 抽象方法的body部分必须用一对大括号{ }包住
- C. 声明抽象方法，大括号可有可无
- D. 声明抽象方法不可写出大括号

答案：D

解析：
- A：abstract 只能修饰类和方法不能修饰字段。
- B：抽象方法没有方法体只有一个声明，所以不需要{}包住。
- C：声明抽象方法大括号不能有，有代表的是有方法体，就与原有抽象方法定义相驳

## 下列语句正确的是（ ）
- A. 形式参数可被视为local variable
- B. 形式参数可被所有的字段修饰符修饰
- C. 形式参数为方法被调用时，是真正被传递的参数
- D. 形式参数不可以是对象

答案：A

解析：
- A：形式参数可被视为local variable。形参和局部变量一样都不能离开方法。都只有在方法内才会发生作用，也只有在方法中使用，不会在方法外可见。
- B：对于形式参数只能用final修饰符，其它任何修饰符都会引起编译器错误。但是用这个修饰符也有一定的限制，就是在方法中不能对参数做任何修改。 不过一般情况下，一个方法的形参不用final修饰。只有在特殊情况下，那就是：方法内部类。一个方法内的内部类如果使用了这个方法的参数或者局部变量的话，这个参数或局部变量应该是final。 
- C：形参的值在调用时根据调用者更改，实参则用自身的值更改形参的值（指针、引用皆在此列），也就是说真正被传递的是实参。
- D：方法的参数列表指定要传递给方法什么样的信息，采用的都是对象的形式。因此，在参数列表中必须指定每个所传递对象的类型及名字。像JAVA中任何传递对象的场合一样，这里传递的实际上也是引用，并且引用的类型必须正确v

## 关于实例方法，下列哪种说法是正确的？
- A. 实例方法可直接调用超类的实例方法
- B．实例方法可直接调用超类的类方法
- C．实例方法可直接调用其他类的实例方法
- D．实例方法可直接调用本类的类方法

答案：D

解析：private 修饰的不能调用

## 下面关于abstract关键字描述错误的是（）
- A. abstract关键字可以修饰类或方法
- B. final类的方法都不能是abstract，因为final类不能有子类
- C. abstract类不能实例化
- D. abstract类的子类必须实现其超类的所有abstract方法

答案：D

解析：对于abstract类的子类来说有两种途径，一种是实现其超类的所有abstract方法；或者是子类也声明为abstract类，将全部实现抽象方法的责任交给它的子类。

## 新建一个流对象，下面哪个选项的代码是错误的？
- A. new BufferedWriter(new FileWriter(“a.txt”));
- B. new BufferedReader(new FileInputStream(“a.dat”));
- C. new GZIPOutputStream(new FileOutputStream(“a.zip”));
- D. new ObjectInputStream(new FileInputStream(“a.dat”));

答案：B

解析：Reader只能用FileReader进行实例化

## 下列关于 Java 变量作用域的说法中，不正确的是（）？
- A. 在 Java 程序中要使用一个变量，必须先对其进行声明
- B. 变量声明语句可以在程序的任何地方，只要在变量使用之前即可
- C. 变量不可以在其作用域之外使用
- D. 局部变量在使用之前可以不初始化，系统使用默认的初始值

答案：D

解析：局部变量在使用之前必须初始化，否则编译错误，类的成员变量则不一定要在使用之前初始化，系统赋予其默认的初始值。

## 下列关于内部类的说法，正确的是（）？
- A. 内部类可以与它包含的类名相同
- B. 内部类只能使用它所在类的静态成员变量，不能使用它所在类的方法中的局部变量
- C. 内部类可以用 abstract 修饰定义为抽象类，不能用 private 或 protected 定义
- D. 外部使用内部类时必须给出类的全名

答案：D

解析：在一个类的内部嵌套定义的类称为内部类，它的类名在定义它的类或程序段中或在表达式内部可以匿名使用。外部使用它时必须给出类的全名。
- A：内部类的类名不允许与它所包含的类名相同
- B：内部类可以使用它所在类的静态成员变量和实例成员变量，也可以使用它所在类的方法中的局部变量
- C：内部类不仅可以用 abstract 修饰定义为抽象类，也可用 private 或 protected 定义

内部类可作为其他类的成员，而且可访问它所在类的成员，除 static 内部类外，不能在类中声明 static 成员。









